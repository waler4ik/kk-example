// Code generated by kk; DO NOT EDIT.

package server

import (
	"context"
	"log"
	"net"
	"net/http"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"golang.org/x/net/netutil"

	"github.com/waler4ik/kk-example/internal/api"
	"github.com/waler4ik/kk-example/internal/config"
)

func NewServer(api *api.API) *Server {
	return &Server{api: api}
}

func (s *Server) ConfigureAPI() {
	config.ConfigureAPI(s.api)
	s.handler = config.ConfigureRouter(s.api)
}

func (s *Server) ConfigureAPIFlags() {
	s.api.CommandLineOptionsGroups = config.ConfigureFlags()
}

type Server struct {
	CleanupTimeout  time.Duration `long:"cleanup-timeout" description:"grace period for which to wait before killing idle connections" default:"10s"`
	GracefulTimeout time.Duration `long:"graceful-timeout" description:"grace period for which to wait before shutting down the server" default:"15s"`

	Host         string        `long:"host" description:"the IP to listen on" default:"localhost" env:"HOST"`
	Port         int           `long:"port" description:"the port to listen on for insecure connections, defaults to a random value" env:"PORT"`
	ListenLimit  int           `long:"listen-limit" description:"limit the number of outstanding requests"`
	KeepAlive    time.Duration `long:"keep-alive" description:"sets the TCP keep-alive timeouts on accepted connections. It prunes dead TCP connections ( e.g. closing laptop mid-download)" default:"3m"`
	ReadTimeout  time.Duration `long:"read-timeout" description:"maximum duration before timing out read of the request" default:"30s"`
	WriteTimeout time.Duration `long:"write-timeout" description:"maximum duration before timing out write of the response" default:"60s"`

	api     *api.API
	handler http.Handler
}

func (s *Server) Serve(ctx context.Context) error {
	listener, err := net.Listen("tcp", net.JoinHostPort(s.Host, strconv.Itoa(s.Port)))
	if err != nil {
		return err
	}

	ctx, stop := signal.NotifyContext(ctx, syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	httpServer := new(http.Server)
	httpServer.ReadTimeout = s.ReadTimeout
	httpServer.WriteTimeout = s.WriteTimeout
	httpServer.SetKeepAlivesEnabled(int64(s.KeepAlive) > 0)
	if s.ListenLimit > 0 {
		listener = netutil.LimitListener(listener, s.ListenLimit)
	}

	if int64(s.CleanupTimeout) > 0 {
		httpServer.IdleTimeout = s.CleanupTimeout
	}

	httpServer.Handler = s.handler

	httpServerStopped := make(chan bool)
	s.Logf("Serving backend at http://%s", listener.Addr())
	go func(l net.Listener) {
		defer func() {
			httpServerStopped <- true
		}()
		if err := httpServer.Serve(l); err != nil && err != http.ErrServerClosed {
			s.Logf("HTTP server stopped with error: %v", err)
		}
		s.Logf("Stopped serving backend at http://%s", l.Addr())
	}(listener)

	select {
	case <-ctx.Done():
		s.shutdown(httpServer)
	case <-httpServerStopped:
	}

	s.Logf("Done")

	return nil
}

func (s *Server) shutdown(server *http.Server) {
	ctx, cancel := context.WithTimeout(context.TODO(), s.GracefulTimeout)
	defer cancel()

	s.Logf("HTTP server shutting down")

	s.api.PreServerShutdown()

	shutdownChan := make(chan bool)
	go func() {
		var success bool
		defer func() {
			shutdownChan <- success
		}()
		if err := server.Shutdown(ctx); err != nil {
			s.Logf("HTTP server Shutdown: %v", err)
		} else {
			success = true
		}
	}()

	if <-shutdownChan {
		s.api.ServerShutdown()
	}
}

func (s *Server) Logf(f string, args ...interface{}) {
	if s.api != nil && s.api.Logger != nil {
		s.api.Logger(f, args...)
	} else {
		log.Printf(f, args...)
	}
}
