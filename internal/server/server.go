// Code generated by kk; DO NOT EDIT.

package server

import (
	"context"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"sync"
	"sync/atomic"
	"syscall"
	"time"

	"golang.org/x/net/netutil"

	"github.com/waler4ik/kk-example/internal/api"
	"github.com/waler4ik/kk-example/internal/config"
)

func NewServer(api *api.API) *Server {
	s := new(Server)
	s.shutdown = make(chan struct{})
	s.api = api
	s.interrupt = make(chan os.Signal, 1)
	return s
}

func (s *Server) ConfigureAPI() {
	config.ConfigureAPI(s.api)
	s.handler = config.ConfigureRouter(s.api)
}

func (s *Server) ConfigureAPIFlags() {
	s.api.CommandLineOptionsGroups = config.ConfigureFlags()
}

type Server struct {
	CleanupTimeout  time.Duration `long:"cleanup-timeout" description:"grace period for which to wait before killing idle connections" default:"10s"`
	GracefulTimeout time.Duration `long:"graceful-timeout" description:"grace period for which to wait before shutting down the server" default:"15s"`

	Host         string        `long:"host" description:"the IP to listen on" default:"localhost" env:"HOST"`
	Port         int           `long:"port" description:"the port to listen on for insecure connections, defaults to a random value" env:"PORT"`
	ListenLimit  int           `long:"listen-limit" description:"limit the number of outstanding requests"`
	KeepAlive    time.Duration `long:"keep-alive" description:"sets the TCP keep-alive timeouts on accepted connections. It prunes dead TCP connections ( e.g. closing laptop mid-download)" default:"3m"`
	ReadTimeout  time.Duration `long:"read-timeout" description:"maximum duration before timing out read of the request" default:"30s"`
	WriteTimeout time.Duration `long:"write-timeout" description:"maximum duration before timing out write of the response" default:"60s"`
	httpListener net.Listener

	api          *api.API
	handler      http.Handler
	hasListeners bool
	shutdown     chan struct{}
	shuttingDown int32
	interrupted  bool
	interrupt    chan os.Signal
}

func (s *Server) Logf(f string, args ...interface{}) {
	if s.api != nil && s.api.Logger != nil {
		s.api.Logger(f, args...)
	} else {
		log.Printf(f, args...)
	}
}

func (s *Server) Fatalf(f string, args ...interface{}) {
	if s.api != nil && s.api.Logger != nil {
		s.api.Logger(f, args...)
		os.Exit(1)
	} else {
		log.Fatalf(f, args...)
	}
}

func (s *Server) Serve() error {
	if !s.hasListeners {
		if err := s.Listen(); err != nil {
			return err
		}
	}

	wg := new(sync.WaitGroup)
	once := new(sync.Once)
	signal.Notify(s.interrupt, syscall.SIGINT, syscall.SIGTERM)
	go handleInterrupt(once, s)

	httpServer := new(http.Server)
	httpServer.ReadTimeout = s.ReadTimeout
	httpServer.WriteTimeout = s.WriteTimeout
	httpServer.SetKeepAlivesEnabled(int64(s.KeepAlive) > 0)
	if s.ListenLimit > 0 {
		s.httpListener = netutil.LimitListener(s.httpListener, s.ListenLimit)
	}

	if int64(s.CleanupTimeout) > 0 {
		httpServer.IdleTimeout = s.CleanupTimeout
	}

	httpServer.Handler = s.handler

	wg.Add(1)
	s.Logf("Serving backend at http://%s", s.httpListener.Addr())
	go func(l net.Listener) {
		defer wg.Done()
		if err := httpServer.Serve(l); err != nil && err != http.ErrServerClosed {
			s.Fatalf("%v", err)
		}
		s.Logf("Stopped serving backend at http://%s", l.Addr())
	}(s.httpListener)

	wg.Add(1)
	go s.handleShutdown(wg, httpServer)

	wg.Wait()
	return nil
}

func (s *Server) Listen() error {
	if s.hasListeners {
		return nil
	}

	listener, err := net.Listen("tcp", net.JoinHostPort(s.Host, strconv.Itoa(s.Port)))
	if err != nil {
		return err
	}

	h, p, err := net.SplitHostPort(listener.Addr().String())
	if err != nil {
		return err
	}
	port, err := strconv.Atoi(p)
	if err != nil {
		return err
	}
	s.Host = h
	s.Port = port
	s.httpListener = listener

	s.hasListeners = true
	return nil
}

func (s *Server) Shutdown() error {
	if atomic.CompareAndSwapInt32(&s.shuttingDown, 0, 1) {
		close(s.shutdown)
	}
	return nil
}

func (s *Server) handleShutdown(wg *sync.WaitGroup, server *http.Server) {
	defer wg.Done()

	<-s.shutdown

	ctx, cancel := context.WithTimeout(context.TODO(), s.GracefulTimeout)
	defer cancel()

	s.api.PreServerShutdown()

	shutdownChan := make(chan bool)
	go func() {
		var success bool
		defer func() {
			shutdownChan <- success
		}()
		if err := server.Shutdown(ctx); err != nil {
			s.Logf("HTTP server Shutdown: %v", err)
		} else {
			success = true
		}
	}()

	if <-shutdownChan {
		s.api.ServerShutdown()
	}
}

func (s *Server) GetHandler() http.Handler {
	return s.handler
}

func (s *Server) SetHandler(handler http.Handler) {
	s.handler = handler
}

func (s *Server) HTTPListener() (net.Listener, error) {
	if !s.hasListeners {
		if err := s.Listen(); err != nil {
			return nil, err
		}
	}
	return s.httpListener, nil
}

func handleInterrupt(once *sync.Once, s *Server) {
	once.Do(func() {
		for range s.interrupt {
			if s.interrupted {
				s.Logf("Server already shutting down")
				continue
			}
			s.interrupted = true
			s.Logf("Shutting down... ")
			if err := s.Shutdown(); err != nil {
				s.Logf("HTTP server Shutdown: %v", err)
			}
		}
	})
}
